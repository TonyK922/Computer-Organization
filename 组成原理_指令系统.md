# 计算机组成原理

> 练拳不练功, 到老一场空. 基础不牢, 地动山摇

## 第4章 指令系统

这一章要讲的内容就是 控制单元中的 排队逻辑, 寄存器和解码器 以及 控制存储器.

![1670321855426](组成原理_指令系统.assets/1670321855426.png)

### 指令的定义

指令又称机器指令, 是指示计算机执行某种操作的命令, 是计算机运行的最小功能单位.

一台计算机的所有指令的集合, 构成该机的指令系统, 也称为指令集.

> 一台计算机只能执行自己指令系统中的指令, 不能执行其它系统的指令.
>
> 指令就是机器语言的一条语句.

### 指令格式

> 一条指令就是机器语言的一条语句, 它是一组有意义的二进制代码.

指令包括:

**`操作码` + `地址码`**

> 操作码:  指明该指令要完成的操作.  操作码是识别指令, 了解指令功能及区分操作数地址内容的组成和使用方法等的关键信息.
>
> 地址码: 用来指出该指令的源操作数的地址(一个或两个), 结果的地址以及下一条指令的地址. 这里的地址可以是主存的, 也可以是寄存器的, 甚至可以是I/O设备的地址.

指令的长度, 就是一条指令中所包含的二进制代码的位数. 指令字长取决于操作码的长度, 操作数地址码的长度和操作数地址的个度.

> 指令的长度, 与机器字长没有固定关系, 它可以等于机器字长, 也可以大于或小于机器字长. 有单字长指令, 半字长指令, 双字长指令.

在一个指令系统中, 若所有**指令的长度**都是相等的, 则成为定长指令字结构. 这种结构, 执行速度快, 控制简单.

若各种指令的长度随指令功能而异, 则称为变字长指令字结构. 主存一般按字节编址, 故指令字长多为字节的整倍数.

**操作码的长度**可以是固定长度, 也可以是可变长度.

> 长度固定是用于指令字长较长的情况, 如RISC ,是为了译码过程的方便, 译码电路简单.
>
> 可变长度, 操作码分散在指令字的不同字段中. 这种格式可有效压缩操作码的平均长度, 在字长较短的微型计算机中被广泛使用.

#### 地址码

根据指令中操作数地址码的数目的不同, 可将指令分成以下几种格式.

- 四地址指令

![1670327362624](组成原理_指令系统.assets/1670327362624.png)

假设指令字长32位, 操作码是8位, 每个地址字段都是6位的. 则指令操作数的直接寻址范围是64.

该指令完成 (A1)OP(A2)→ A3, A1地址中的内容. 举个例子:

![1670328380213](组成原理_指令系统.assets/1670328380213.png)

上面这个例子 操作码是加法, 那这条指令的意思就是 A1中的数据加A2中的数据, 结果放到A3地址中. 然后执行下一条取A4地址中的指令.   注意, 这里数据跟指令混合乱放的.

前面章节说了, 程序大多是按顺序执行的, 程序计数器PC既能存放当前将执行指令的存放地址, 又能自加1.所以只需要把指令放一起, 数据放一起, 分开放置, 指令按顺序放, 就可以不要A4. 比如这样

![1670383855971](组成原理_指令系统.assets/1670383855971.png) ![1670383881115](组成原理_指令系统.assets/1670383881115.png)

那就可以得到以下这种:

- 三地址指令

  ![1670328624335](组成原理_指令系统.assets/1670328624335.png)

  依旧是完成(A1)OP(A2)→A3, 后续指令的地址隐含在PC中, 有PC中的地址自加1完成. OP仍为8位, 三个地址字段也占8位, 那三地址指令操作数的直接寻址范围可达256. 若地址都是主存地址, 也需要访存4次.

  那如果在运行过程中, 把中间结果先暂存在CPU的寄存器(如累加器ACC)中, 最终结果再写到主存里, 这样放中间结果的A3地址也不需要了.得到下面这种:

- 二地址指令

  ![1670387507126](组成原理_指令系统.assets/1670387507126.png)

  它完成(A1)OP(A2) → A1的操作. A1字段既代表源操作数的地址, 又代表存放运算结果的地址.此时依旧需要访问4次内存. 若把结果放在ACC寄存器中, 则只访问3次内存. 二地址指令操作数的直接寻址范围是2的12次方.

  接下来把一个操作数的地址隐含在ACC中.则有了下面这种:

- 一地址指令

  ![1670410434013](组成原理_指令系统.assets/1670410434013.png)

  它可完成(ACC)OP(A1) → ACC的操作. ACC 既存放参与运算的操作数, 又存放运算的中间结果, 这样, 完成一条一地址指令只需两次访存. 在指令字长仍为32 位, 操作码位数仍固定为8位时, 一地址指令操作数的直接寻址范围达2的24次方, 即16 M.

- 零地址指令

  零地址指令在指令字中无地址码, 例如, 空操作(NOP) , 停机(HLT) 这类指令只有操作码. 而子程序返回(RET), 中断返回(IRET) 这类指令没有地址码, 其操作数的地址隐含在堆栈指针SP 中. 

  > 零地址的运算类指令仅用在堆栈计算机中. 通常参与运算的两个操作数隐含地依次从栈顶弹出. 送到运算器执行运算, 结果再隐式地压入堆栈.

通过上述介绍可见, 用一些硬件资源(如PC 、ACC) 承担指令字中需指明的地址码, 可在不改变指令字长的前提下, 扩大指令操作数的直接寻址范围. 此外, 用PC 、ACC 等硬件代替指令字中的某些地址字段, 还可缩短指令字长, 并可减少访存次数. 因此, 究竟采用什么样的地址格式, 必须从机器性能出发综合考虑. 

以上讨论的地址格式均以主存地址为例, 实际上地址字段也可用来表示寄存器. 当CPU 中含有多个通用寄存器时, 对每一个寄存器赋予一个编号, 便可指明源操作数和结果存放在哪个寄存器中. 地址字段表示寄存器时, 也可有三地址, 二地址, 一地址之分. 它们的共同点是, 在指令的执行阶段都不必访问存储器, 直接访问寄存器, 使机器运行速度得到提高(因为寄存器类型的指令只需在取指阶段访问一次存储器). 

#### 定长操作码指令格式

上面介绍了, 操作码分定长跟可变两种.

定长操作码指令, 就是在指令字的最高位部分分配固定的若干位(定长)表示操作码. n位操作码字段的指令系统最大能表是2的n次方条指令. 定长操作码对简化计算机硬件设计, 提高指令译码和识别速度很有利. 当计算机字长为32位或更长, 这是常规方法.

#### 扩展操作码指令格式

为了在指令字长有限的前提下, 仍保持比较丰富的指令种类, 可采用可变长度操作码, 即全部指令的操作码字段的位数不固定, 且分散地放在指令字的不同位置上. 但将增加指令译码和分析的难度, 使控制器的设计复杂化.

通常采用扩展操作码技术, 使操作码的长度随地址数的减少而增加, 不同地址数的指令可以具有不同长度的操作码, 从而在满足需要的前提下, 有效地缩短指令字长.

扩展操作码举例:

假设现在有16位指令字长, 前4位为基本操作码字段OP, 另有3个4位长的地址字段.

![1670412348034](组成原理_指令系统.assets/1670412348034.png)

这是一种扩展方法.

设计扩展码指令格式时, 要注意:

- 不允许短码是长码的前缀, 即短操作码不能与长操作码的前面部分相同.
- 各指令的操作码一定不能重复.
- 通常情况下, 对使用频率较高的指令, 分配较短的操作码; 从而尽可能减少指令译码和分析的时间.

另一种设计:

![1670413498287](组成原理_指令系统.assets/1670413498287.png)

#### 指令字长

指令字长取决于操作码的长度, 操作数地址的长度和操作数地址的个数. 

不同机器的指令字长是不相同的. 早期的计算机指令字长, 机器字长和存储字长均相等, 因此访问某个存储单元, 便可取出一条完整的指令或一个完整的数据. 这种机器的指令字长是固定的, 控制方式比较简单. 随着计算机的发展, 存储容量的增大, 要求处理的数据类型增多, 计算机的指令字长也发生了很大的变化. 一台机器的指令系统可以采用位数不相同的指令, 即指令字长是可变的, 如单字长指令, 多字长指令. 控制这类指令的电路比较复杂, 而且多字长指令要多次访问存储器才能取出一条完整的指令, 因此使CPU 速度下降. 为了提高指令的运行速度和节省存储空间, 通常尽可能把常用的指(如数据传送指令, 算逻运算指令等)设计成单字长或短字长格式的指令.

### 操作数类型

机器中常见的操作数类型有地址, 数字, 字符, 逻辑数据等.

#### 地址

地址实际上也可看作是一种数据, 在许多情况下要计算操作数的地址. 这时, 地址可被认为是一个无符号的整数.

#### 数字

计算机中常见的数字有定点数、浮点数和十进制数

#### 字符

在应用计算机时, 文本或者字符串也是一种常见的数据类型. 由于计算机在处理信息过程中不能以简单的字符形式存储和传送, 因此普遍采用ASCII 码, 它是很重要的一种符编码. 当然还有其他一些字符编码, 如8 位EBCDIC 码(Extended Binary Coded Decimal InterchangeCode), 又称扩展BCD 交换码.

#### 逻辑数据

计算机除了做算术运算外, 有时还需做逻辑运算, 此时n个0和1的组合不是被看作算术数字, 而是被看作逻辑数.

例如, 在ASCII码中的0110101, 它表示十进制数5, 若要将它转换为NBCD短十进制码, 只需通过它与逻辑数0001111 完成逻辑与运算, 抽取低4 位, 即可获得0101. 此外, 有时希望存储一个布尔类型的数据, 它们的每一位都代表着真(1) 和假(0) , 这时n个0和1组合的数就都被看作逻辑数.

### 数据在存储器中的存放方式

通常计算机中的数据存放在存储器或寄存器中, 而寄存器的位数便可反映机器字长. 一般机器字长可取字节的1, 2, 4 , 8 倍, 这样便千字符处理. 在大, 中型机器中字长为32 位和64 位, 在微型计算机中字长从4 位, 8 位逐渐发展到目前的16 位, 32 位和64 位.

由于不同的机器数据字长不同，每台机器处理的数据字长也不统一. 因此, 为了便于硬件实现, 通常要求多字节的数据在存储器的存放方式能满足"边界对准"的要求，

总结: 边界对齐 与 边界不对齐,  大端方式与小端方式. 前面讲过了.

> 区分大小端, 就是看计算机先读到的是 高字节还是低字节.

![1670420906334](组成原理_指令系统.assets/1670420906334.png)

### 操作类型

不同的机器, 操作类型也是不同的, 但几乎所有的机器都有以下几类通用的操作.

#### 数据传送

数据传送包括寄存器与寄存器, 寄存器与存储单元, 存储单元与存储单元之间的传送. 如从源到目的之间的传送, 对存储器读(LOAD) 和写(STORE) , 交换源和目的的内容, 置1 , 清零, 进栈、出栈等。

#### 算术逻辑操作

这类操作可实现算术运算(加, 减, 乘, 除, 增1, 减1 , 取负数即求补)和逻辑运算(与, 或, 非, 异或). 对低档机而言, 一般算术运算只支持最基本的二进制加减, 比较, 求补等, 高档机还能支持浮点运算和十进制运算. 
有些机器还具有位操作功能, 如位测试(测试指定位的值), 位清除(清除指定位), 位求反(对指定位求反)等.

#### 移位

移位可分为算术移位, 逻辑移位和循环移位三种. 算术移位和逻辑移位分别可实现对有符号数和无符号数乘以2\^n(左移)或整除以2\^n(右移)的运算, 并且**移位操作所需时间远比乘除操作执行时间短**, 因此, 移位操作经常被用来代替简单的乘法和除法运算. 

#### 转移

在多数情况下, 计算机是按顺序执行程序的每条指令的, 但有时需要改变这种顺序, 此刻可采用转移类指令来完成. 转移指令按其转移特征又可分为无条件转移, 条件转移, 跳转, 过程调用与返回, 陷阱(Trap) 等几种.